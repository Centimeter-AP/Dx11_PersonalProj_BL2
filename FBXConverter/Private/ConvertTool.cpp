#include "GameInstance.h"
#include "ConvertTool.h"

//ImGuiFileDialog g_ImGuiFileDialog;
//ImGuiFileDialog::Instance() 이래 싱글톤으로 쓰라고 신이 말하고 감


CConvertTool::CConvertTool(ID3D11Device* pDevice, ID3D11DeviceContext* pContext)
	: CImGuiTool{ pDevice, pContext }
{

}

CConvertTool::CConvertTool(const CConvertTool& Prototype)
	: CImGuiTool(Prototype)
{
}

HRESULT CConvertTool::Initialize_Prototype()
{
	return S_OK;
}

HRESULT CConvertTool::Initialize(void* pArg)
{
	if (FAILED(__super::Initialize(pArg)))
		return E_FAIL;
	savePath = R"(C:\Users\CMAP\Documents\Dx11_Personal_Projects\3d\testing)";


	return S_OK;
}

void CConvertTool::Priority_Update(_float fTimeDelta)
{

}

void CConvertTool::Update(_float fTimeDelta)
{
}

void CConvertTool::Late_Update(_float fTimeDelta)
{
}

HRESULT CConvertTool::Render()
{
	if (m_pWindowData->ShowConvertMenu)
	{
		if (FAILED(Render_ConvertTool()))
			return E_FAIL;
	}

	return S_OK;
}

HRESULT CConvertTool::Render_ConvertTool()
{
	SetNextWindowSize(ImVec2(200, 300));
	Begin("Convert Tools", &m_pWindowData->ShowConvertMenu, NULL);
	
	IGFD::FileDialogConfig config;
	if (Button("Load NonAnim File"))
	{
		m_isAnim = false;
		config.path = R"(C:\Users\CMAP\Documents\Dx11_Personal_Projects\3d\Borderlands2 Exports\Borderlands2_ALL\Frost_P\StaticMesh3\FBX)";
		//config.path = R"(C:\Users\CMAP\Documents\Dx11_Personal_Projects\3d\Borderlands2 Exports\Frost_StaticMesh)";
		config.countSelectionMax = 0; // 무제한

		IFILEDIALOG->OpenDialog("FBXDialog", "Select Non Anim Staticmesh FBX Files", ".fbx", config);
	}

	if (Button("Load Anim File"))
	{
		m_isAnim = true;
		config.path = R"(C:\Users\CMAP\Documents\Dx11_Personal_Projects\3d\Borderlands2 Exports\Borderlands2_ALL\Frost_P\StaticMesh3\FBX)";
		config.countSelectionMax = 0; // 무제한

		IFILEDIALOG->OpenDialog("FBXDialog", "Select Anim Skeletalmesh FBX Files", ".fbx", config);
	}

	if (IFILEDIALOG->Display("FBXDialog"))
	{
		if (IFILEDIALOG->IsOk())
		{
			auto selections = IFILEDIALOG->GetSelection();
			// 처리
			// first: 파일명.확장자
			// second: 전체 경로 (파일명포함)
			if (!selections.empty())
			{
				for (auto FilePath : selections)
				{
					if (false == m_isAnim)
						Convert_NonAnimFBX(FilePath.second.data());
					else
						Convert_AnimFBX(FilePath.second.data());
				}
			}
			Copy_MaterialTextures();
		}
		IFILEDIALOG->Close();
	}

	SeparatorText("Find Object");
	End();
	return S_OK;
}

HRESULT CConvertTool::Convert_NonAnimFBX(const _char* pModelFilePath)
{
	FBXDATA m_tFBXData = { };
	if (FAILED(Ready_FBXData(pModelFilePath, m_tFBXData)))
		return E_FAIL;
	string saveFileName = savePath + "\\" + m_tFBXData.strFBXName + ".bin";
	ofstream ofs(saveFileName, ios::binary);
	if (!ofs.is_open())
	{
		MSG_BOX("숏됏어요");
		return E_FAIL;
	}

//	야가다를 해요
//****메쉬
	ofs.write(reinterpret_cast<const char*>(&m_tFBXData.iNumMeshes),sizeof(_uint)); // 메쉬 몇개?
	for (auto meshdata : m_tFBXData.vecMeshes)										// 메쉬 전체 다 돌아요
	{
		ofs.write(reinterpret_cast<const char*>(&meshdata.iMaterialIndex), sizeof(_uint));	// 머테리얼 인덱스 저장해요
		ofs.write(reinterpret_cast<const char*>(&meshdata.iNumVertices), sizeof(_uint));	// 버텍스 몇갠지 저장해요
		ofs.write(reinterpret_cast<const char*>(&meshdata.iNumIndices), sizeof(_uint));		// 인덱스 몇갠지 저장해요
		ofs.write(reinterpret_cast<const char*>(meshdata.vecIndices.data()), meshdata.iNumIndices * sizeof(_uint));		// 인덱스 벡터 배열로 통짜저장해요
		ofs.write(reinterpret_cast<const char*>(meshdata.vecVertices.data()), meshdata.iNumVertices * sizeof(VTXMESH)); // 버텍스 벡터 구조체 배열도 통짜저장해요~ㅋㅋ
	}
//****머테리얼
	ofs.write(reinterpret_cast<const char*>(&m_tFBXData.iNumMaterials),sizeof(_uint));	// 머테리얼 몇개?
	for (auto material : m_tFBXData.vecMaterials)										// 머테리얼 전체 다 돌아요
	{
		_uint numSRVs = material.size();
		ofs.write(reinterpret_cast<const char*>(&numSRVs), sizeof(_uint));						// 머테리얼 안에 srv가 몇개 있는지 저장해요(구조체에없으니까조심!!)			
		for (auto matdata : material)															// 저장해요	
		{
			_uint texType = static_cast<_uint>(matdata.eTexType);								// 텍스쳐 타입 uint로 바꺼줘요
			ofs.write(reinterpret_cast<const char*>(&texType), sizeof(_uint));					// 저장해요
			_uint pathLength = static_cast<_uint>(matdata.strTexturePath.size());				// 문자열 길이 구해요
			ofs.write(reinterpret_cast<const char*>(&pathLength), sizeof(_uint));				// 문자열 길이 저장해요
			if (pathLength > 0)
				ofs.write(matdata.strTexturePath.data(), pathLength);							// 문자열 저장해요
		}							
	}

	return S_OK;

}

HRESULT CConvertTool::Convert_AnimFBX(const _char* pModelFilePath)
{
	path ModelPath = pModelFilePath;
	path saveFileName = savePath / ModelPath.stem();
	saveFileName.replace_extension(".bin");
	ofstream ofs(saveFileName, ios::binary);
	if (!ofs.is_open())
	{
		MSG_BOX("숏됏어요");
		return E_FAIL;
	}
	if (FAILED(Ready_FBXData(pModelFilePath, ofs)))
		return E_FAIL;

	int		iFlag = aiProcess_ConvertToLeftHanded | aiProcessPreset_TargetRealtime_Fast;


	m_pAIScene = m_Importer.ReadFile(pModelFilePath, iFlag);

	if (nullptr == m_pAIScene)
	{
		MSG_BOX("어심프가 쓰러졌다 !!! 무슨일이야 !!!");
		return E_FAIL;
	}


/********************순서********************/
/**** 본 -> 메쉬 -> 머테리얼 -> 애니메이션 ****/
/*******************************************/

/**********본 저장**********/
	vector<string> BoneNames;
	Write_BoneData(m_pAIScene->mRootNode, -1, BoneNames, ofs);

/**********메쉬 저장**********/
	ofs.write(reinterpret_cast<const char*>(&m_pAIScene->mNumMeshes), sizeof(_uint)); // 메쉬 몇개?
	for (size_t i = 0; i < m_pAIScene->mNumMeshes; i++)
	{
		aiMesh* pAIMesh = m_pAIScene->mMeshes[i];
		
		ofs.write(reinterpret_cast<const char*>(&pAIMesh->mName.length), sizeof(_uint));	// 메쉬 이름 길이 저장해요
		ofs.write(reinterpret_cast<const char*>(&pAIMesh->mName.data), pAIMesh->mName.length);		// 메쉬 이름 저장해요
		
		ofs.write(reinterpret_cast<const char*>(&pAIMesh->mMaterialIndex), sizeof(_uint));	// 머테리얼 인덱스 저장해요

		_uint iNumVertices = pAIMesh->mNumVertices;
		ofs.write(reinterpret_cast<const char*>(&iNumVertices), sizeof(_uint));	// 버텍스 몇갠지 저장해요

		_uint iNumIndices = pAIMesh->mNumFaces * 3;
		ofs.write(reinterpret_cast<const char*>(&iNumIndices), sizeof(_uint));		// 인덱스 몇갠지 저장해요

		vector<VTXANIMMESH> pVertices;
		pVertices.reserve(iNumVertices);
		for (size_t j = 0; j < iNumVertices; j++)
		{
			memcpy(&pVertices[j].vPosition, &pAIMesh->mVertices[j], sizeof(_float3));
			memcpy(&pVertices[j].vNormal, &pAIMesh->mNormals[j], sizeof(_float3));
			memcpy(&pVertices[j].vTangent, &pAIMesh->mTangents[j], sizeof(_float3));
			memcpy(&pVertices[j].vTexcoord, &pAIMesh->mTextureCoords[0][j], sizeof(_float2));
		}

		_uint iNumBones = pAIMesh->mNumBones;
		ofs.write(reinterpret_cast<const char*>(&iNumBones), sizeof(_uint));		// 이 메쉬에 영향을 주는 뼈가 몇갠지 저장해요
		vector<_float4x4> OffsetMatrices;
		vector<_uint> BoneIndices;
		for (size_t j = 0; j < iNumBones; j++)
		{
			aiBone* pAIBone = pAIMesh->mBones[j];
			_float4x4		OffsetMatrix;
			memcpy(&OffsetMatrix, &pAIBone->mOffsetMatrix, sizeof(_float4x4));
			XMStoreFloat4x4(&OffsetMatrix, XMMatrixTranspose(XMLoadFloat4x4(&OffsetMatrix)));

			OffsetMatrices.push_back(OffsetMatrix);

			_uint	iBoneIndex = {};
			auto	iter = find_if(BoneNames.begin(), BoneNames.end(), [&](string BoneName)->_bool
				{
					if (!strcmp(BoneName.c_str(), pAIBone->mName.C_Str()))
						return true;

					++iBoneIndex;

					return false;
				});

			BoneIndices.push_back(iBoneIndex);
			_uint		iNumWeights = pAIBone->mNumWeights;
			ofs.write(reinterpret_cast<const char*>(&iNumWeights), sizeof(_uint));		// 지금의 뼈가 영향을 끼칠 수 있는 버텍스의 갯수를 저장해요 /* i번째 뼈가 몇개 정점에게 영향을 주는데?*/

			for (_uint k = 0; k < iNumWeights; k++)
			{
				/* i번째 뼈가 영향ㅇ르 주는 k번째 정점의 정보 */
				aiVertexWeight	AIWeight = pAIBone->mWeights[k];

				if (0.f == pVertices[AIWeight.mVertexId].vBlendWeights.x)
				{
					/* 이 메시에게 영향을 주는 뼈들 중 i번째 뼈가 이 정점에게 영향을 주네. */
					pVertices[AIWeight.mVertexId].vBlendIndices.x = i;
					pVertices[AIWeight.mVertexId].vBlendWeights.x = AIWeight.mWeight;
				}

				else if (0.f == pVertices[AIWeight.mVertexId].vBlendWeights.y)
				{
					pVertices[AIWeight.mVertexId].vBlendIndices.y = i;
					pVertices[AIWeight.mVertexId].vBlendWeights.y = AIWeight.mWeight;
				}

				else if (0.f == pVertices[AIWeight.mVertexId].vBlendWeights.z)
				{
					pVertices[AIWeight.mVertexId].vBlendIndices.z = i;
					pVertices[AIWeight.mVertexId].vBlendWeights.z = AIWeight.mWeight;
				}

				else if (0.f == pVertices[AIWeight.mVertexId].vBlendWeights.w)
				{
					pVertices[AIWeight.mVertexId].vBlendIndices.w = i;
					pVertices[AIWeight.mVertexId].vBlendWeights.w = AIWeight.mWeight;
				}
			}
			if (0 == iNumBones)
			{
				iNumBones = 1;

				_uint	iBoneIndex = {};

				auto	iter = find_if(BoneNames.begin(), BoneNames.end(), [&](string BoneName)->_bool
					{
						if (!strcmp(BoneName.c_str(), pAIBone->mName.C_Str()))
							return true;

						++iBoneIndex;

						return false;
					});


				BoneIndices.push_back(iBoneIndex);

				_float4x4		OffsetMatrix;
				XMStoreFloat4x4(&OffsetMatrix, XMMatrixIdentity());
				OffsetMatrices.push_back(OffsetMatrix);
			}
		}

		ofs.write(reinterpret_cast<const char*>(OffsetMatrices.data()), sizeof(_float4x4) * OffsetMatrices.size());		// 오프셋 행렬 배열 저장해요
		ofs.write(reinterpret_cast<const char*>(BoneIndices.data()), sizeof(_uint) * BoneIndices.size());				// 나한테 영향을 미치는 뼈새끼 인덱스가 몇번인지에 대한 배열 저장해요
		ofs.write(reinterpret_cast<const char*>(pVertices.data()), iNumVertices * sizeof(VTXANIMMESH));					// 버텍스 벡터 구조체 배열도 저장해요
		
		vector<_uint> pIndices;
		pIndices.reserve(iNumIndices);

		for (size_t j = 0; j < m_pAIScene->mMeshes[i]->mNumFaces; j++)	// 인덱스 채워요
		{
			pIndices.push_back(pAIMesh->mFaces[j].mIndices[0]);
			pIndices.push_back(pAIMesh->mFaces[j].mIndices[1]);
			pIndices.push_back(pAIMesh->mFaces[j].mIndices[2]);
		}
		ofs.write(reinterpret_cast<const char*>(pIndices.data()), iNumIndices * sizeof(_uint));		// 인덱스 벡터 배열로 통짜저장해요
	}
	// 아니 말이 안대잖아 이게 다 메쉬라고? 으윽, 


/**********머테리얼 저장**********/
	_uint iNumMaterials = m_pAIScene->mNumMaterials;								
	ofs.write(reinterpret_cast<const char*>(&iNumMaterials), sizeof(_uint));			// 머테리얼 몇갠지 저장해요
	for (size_t i = 0; i < iNumMaterials; ++i)											// 머테리얼 전체 다 돌아요
	{
		aiMaterial* pMaterial = m_pAIScene->mMaterials[i];
		vector<FBX_MATDATA> tMaterialData;
		for (_uint j = 1; j < AI_TEXTURE_TYPE_MAX; j++)				// 죳뺑이쳐요
		{
			_uint iNumSRVs = pMaterial->GetTextureCount(static_cast<aiTextureType>(j));
			for (size_t k = 0; k < iNumSRVs; k++)
			{
				FBX_MATDATA tMat = {};
				aiString     strTexturePath;
				if (FAILED(m_pAIScene->mMaterials[i]->GetTexture(static_cast<aiTextureType>(j), k, &strTexturePath)))
					return E_FAIL;

				_char       szFullPath[MAX_PATH] = {};
				_char       szFileName[MAX_PATH] = {};
				_char       szDriveName[MAX_PATH] = {};
				_char       szDirName[MAX_PATH] = {};
				_char       szExt[MAX_PATH] = {}; // 저장은 이름이랑 확장자만 저장하자

				_char		szFBXName[MAX_PATH] = {};


				_splitpath_s(pModelFilePath, szDriveName, MAX_PATH, szDirName, MAX_PATH, szFBXName, MAX_PATH, nullptr, 0);
				_splitpath_s(strTexturePath.data, nullptr, 0, nullptr, 0, szFileName, MAX_PATH, szExt, MAX_PATH);

				path relPath = strTexturePath.data;
				path fbxTexturePath = (path)szDriveName / szDirName;
				fbxTexturePath /= relPath;
				fbxTexturePath = fbxTexturePath.lexically_normal();

				materialList.push_back(fbxTexturePath); // 나중에 저장할 때 복사붙여넣기 해줄 텍스쳐들 경로 모아두자 

				strcat_s(szFullPath, szFileName);
				strcat_s(szFullPath, szExt);


				tMat.strTexturePath = szFullPath;					// 텍스쳐 이름이랑 확장자만 저장
				tMat.eTexType = static_cast<aiTextureType>(j);		// 텍스쳐타입 뭐였는지 저장하시고
				tMaterialData.push_back(tMat);

			}
		}
		_uint numSRVs = tMaterialData.size();
		ofs.write(reinterpret_cast<const char*>(&numSRVs), sizeof(_uint));						// 머테리얼 안에 srv가 몇개 있는지 저장해요
		for (auto matdata : tMaterialData)													
		{
			_uint texType = static_cast<_uint>(matdata.eTexType);								// 텍스쳐 타입 uint로 바꺼줘요
			ofs.write(reinterpret_cast<const char*>(&texType), sizeof(_uint));					// 저장해요
			_uint pathLength = static_cast<_uint>(matdata.strTexturePath.size());				// 문자열 길이 구해요
			ofs.write(reinterpret_cast<const char*>(&pathLength), sizeof(_uint));				// 문자열 길이 저장해요
			if (pathLength > 0)
				ofs.write(matdata.strTexturePath.data(), pathLength);							// 문자열 저장해요
		}
	}

	return S_OK;
}

HRESULT CConvertTool::Copy_MaterialTextures()
{
	for (auto srcPath : materialList)
	{
		try
		{
			_char       szFileName[MAX_PATH] = {};
			_char       szExt[MAX_PATH] = {}; // 저장은 이름이랑 확장자만 저장하자
		
			_splitpath_s(srcPath.string().c_str(), nullptr, 0, nullptr, 0, szFileName, MAX_PATH, szExt, MAX_PATH);

			string dstPath = savePath + "\\" + szFileName + szExt;

			if (false == copy_file(srcPath, dstPath, copy_options::overwrite_existing))
				continue;
		}	
		catch (const filesystem_error& e)
		{
			// 1) 에러 정보를 하나의 std::string으로 조합
			std::string msg = "파일 복사 실패:\n";
			msg += e.what();
			msg += "\n\n코드 값: " + std::to_string(e.code().value());
			msg += "\n에러 메시지: " + e.code().message();
			msg += "\n원본 경로: " + e.path1().string();
			msg += "\n대상 경로: " + e.path2().string();

			// 2) MessageBoxA로 출력
			MessageBoxA( nullptr, msg.c_str(), "파일 복사 오류", MB_OK | MB_ICONERROR );
			continue;
		}          
	}
	materialList.clear();
	return S_OK;
}

HRESULT CConvertTool::Ready_FBXData(const _char* pModelFilePath, ofstream& ofs)
{
	return E_NOTIMPL;
}


HRESULT CConvertTool::Ready_FBXData(const _char* pModelFilePath, FBXDATA& m_pFBXData)
{
	int		iFlag = aiProcess_ConvertToLeftHanded | aiProcessPreset_TargetRealtime_Fast | aiProcess_PreTransformVertices;


	m_pAIScene = m_Importer.ReadFile(pModelFilePath, iFlag);

	if (nullptr == m_pAIScene)
	{
		MSG_BOX("어심프가 쓰러졌다 !!! 무슨일이야 !!!");
		return E_FAIL;
	}
	Ready_FBX_BoneData(m_pFBXData);
	Ready_FBX_MeshData(m_pFBXData);
	Ready_FBX_MaterialData(pModelFilePath, m_pFBXData);
	Ready_FBX_AnimationData(m_pFBXData);
	return S_OK;
}

HRESULT CConvertTool::Write_BoneData(const aiNode* pAINode, _int iParentBoneIndex, vector<string>& m_BoneNames, ostream& ofs)
{
	{ // 뼈 Create
		ofs.write(reinterpret_cast<const char*>(&pAINode->mName.length), sizeof(_uint));	// 뼈 이름 길이 저장해요
		ofs.write(reinterpret_cast<const char*>(&pAINode->mName.data), pAINode->mName.length);	// 뼈 이름 저장해요
		m_BoneNames.push_back(pAINode->mName.data);

		_float4x4 TransformationMatrix = {};
		memcpy(&TransformationMatrix, &pAINode->mTransformation, sizeof(_float4x4));
		XMStoreFloat4x4(&TransformationMatrix, XMMatrixTranspose(XMLoadFloat4x4(&TransformationMatrix)));
		ofs.write(reinterpret_cast<const char*>(&TransformationMatrix), sizeof(_float4x4));	// 행렬 저장해요
		ofs.write(reinterpret_cast<const char*>(&iParentBoneIndex), sizeof(_int));			// 부모 뼈 인덱스 저장해요
	}

	++m_iCurNumBones;
	_int		iParentIndex = m_iCurNumBones - 1;

	for (size_t i = 0; i < pAINode->mNumChildren; i++)
	{
		Write_BoneData(pAINode->mChildren[i], iParentIndex, m_BoneNames, ofs);
	}
	return S_OK;
}

HRESULT CConvertTool::Ready_FBX_MeshData(FBXDATA& m_pFBXData)
{
	m_pFBXData.iNumMeshes = m_pAIScene->mNumMeshes;						// 메쉬부터 채워요
	m_pFBXData.vecMeshes.reserve(m_pFBXData.iNumMeshes);
	for (size_t i = 0; i < m_pFBXData.iNumMeshes; i++)
	{
		FBX_MESHDATA tMesh = {};

		tMesh.iMaterialIndex = m_pAIScene->mMeshes[i]->mMaterialIndex;	// 사용하는 머테리얼 인덱스 번호
		tMesh.iNumVertices = m_pAIScene->mMeshes[i]->mNumVertices;		// 버텍스 갯수
		tMesh.iNumIndices = m_pAIScene->mMeshes[i]->mNumFaces * 3;		// 인덱스 갯수
		tMesh.vecVertices.reserve(tMesh.iNumVertices);					// 벡터 리저브 해줘요
		tMesh.vecIndices.reserve(tMesh.iNumIndices);

		for (size_t j = 0; j < tMesh.iNumVertices; j++)					// 정점 구조체 채워요
		{
			VTXMESH tVtxMesh;
			memcpy(&tVtxMesh.vPosition, &m_pAIScene->mMeshes[i]->mVertices[j], sizeof(_float3));
			memcpy(&tVtxMesh.vNormal, &m_pAIScene->mMeshes[i]->mNormals[j], sizeof(_float3));
			memcpy(&tVtxMesh.vTangent, &m_pAIScene->mMeshes[i]->mTangents[j], sizeof(_float3));
			memcpy(&tVtxMesh.vTexcoord, &m_pAIScene->mMeshes[i]->mTextureCoords[0][j], sizeof(_float2));
			tMesh.vecVertices.push_back(tVtxMesh);
		}

		for (size_t j = 0; j < m_pAIScene->mMeshes[i]->mNumFaces; j++)	// 인덱스 채워요
		{
			tMesh.vecIndices.push_back(m_pAIScene->mMeshes[i]->mFaces[j].mIndices[0]);
			tMesh.vecIndices.push_back(m_pAIScene->mMeshes[i]->mFaces[j].mIndices[1]);
			tMesh.vecIndices.push_back(m_pAIScene->mMeshes[i]->mFaces[j].mIndices[2]);
		}

		m_pFBXData.vecMeshes.push_back(tMesh);							// 밥먹어
	}
	return S_OK;
}

HRESULT CConvertTool::Ready_FBX_MaterialData(const _char* pModelFilePath, FBXDATA& m_pFBXData)
{

	m_pFBXData.iNumMaterials = m_pAIScene->mNumMaterials;				// 머테리얼 채워요
	for (size_t i = 0; i < m_pFBXData.iNumMaterials; i++)
	{
		vector<FBX_MATDATA> tMaterialData;
		for (size_t j = 1; j < AI_TEXTURE_TYPE_MAX; j++)				// 죳뺑이쳐요
		{
			_uint iNumSRVs = m_pAIScene->mMaterials[i]->GetTextureCount(static_cast<aiTextureType>(j));
			for (size_t k = 0; k < iNumSRVs; k++)
			{
				FBX_MATDATA tMat = {};
				aiString     strTexturePath;
				if (FAILED(m_pAIScene->mMaterials[i]->GetTexture(static_cast<aiTextureType>(j), k, &strTexturePath)))
					return E_FAIL;

				_char       szFullPath[MAX_PATH] = {};
				_char       szFileName[MAX_PATH] = {};
				_char       szDriveName[MAX_PATH] = {};
				_char       szDirName[MAX_PATH] = {};
				_char       szExt[MAX_PATH] = {}; // 저장은 이름이랑 확장자만 저장하자

				_char		szFBXName[MAX_PATH] = {};


				_splitpath_s(pModelFilePath, szDriveName, MAX_PATH, szDirName, MAX_PATH, szFBXName, MAX_PATH, nullptr, 0);
				m_pFBXData.strFBXName = szFBXName; // 내보낼 파일 이름 저장하게 fbx파일 명 저장해요

				_splitpath_s(strTexturePath.data, nullptr, 0, nullptr, 0, szFileName, MAX_PATH, szExt, MAX_PATH);

				path relPath = strTexturePath.data;
				path fbxTexturePath = (path)szDriveName / szDirName;
				fbxTexturePath /= relPath;	
				fbxTexturePath = fbxTexturePath.lexically_normal();
				//path cleaned;
				//for (auto& part : fbxTexturePath) {
				//	if (part == "." || part == "..")
				//		continue;
				//	cleaned /= part;
				//}
				//
				//cleaned.lexically_normal();
				//path basePath = R"(C:\Users\CMAP\Documents\Dx11_Personal_Projects\3d\Borderlands2 Exports\Borderlands2_ALL\)";
				//path absPath = basePath / cleaned;
				//absPath = absPath.lexically_normal();

				materialList.push_back(fbxTexturePath); // 나중에 저장할 때 복사붙여넣기 해줄 텍스쳐들 경로 모아두자 

				strcat_s(szFullPath, szFileName);
				strcat_s(szFullPath, szExt);

				tMat.strTexturePath = szFullPath;					// 텍스쳐 이름이랑 확장자만 저장
				tMat.eTexType = static_cast<aiTextureType>(j);		// 텍스쳐타입 뭐였는지 저장하시고
				tMaterialData.push_back(tMat);
			}
		}
		m_pFBXData.vecMaterials.push_back(tMaterialData);
	}
	return S_OK;
}

HRESULT CConvertTool::Ready_FBX_BoneData(FBXDATA& m_pFBXData)
{
	return S_OK;
}

HRESULT CConvertTool::Ready_FBX_AnimationData(FBXDATA& m_pFBXData)
{
	return S_OK;
}



CConvertTool* CConvertTool::Create(ID3D11Device* pDevice, ID3D11DeviceContext* pContext, void* pArg)
{
	CConvertTool* pInstance = new CConvertTool(pDevice, pContext);

	if (FAILED(pInstance->Initialize(pArg)))
	{
		MSG_BOX("Failed to Created : CConvertTool");
		Safe_Release(pInstance);
	}

	return pInstance;
}

CGameObject* CConvertTool::Clone(void* pArg)
{
	CConvertTool* pInstance = new CConvertTool(*this);

	if (FAILED(pInstance->Initialize(pArg)))
	{
		MSG_BOX("Failed to Cloned : CConvertTool");
		Safe_Release(pInstance);
	}

	return pInstance;
}


void CConvertTool::Free()
{
	__super::Free();

}
